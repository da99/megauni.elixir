

defmodule Megauni.Repos.Main do
  use Ecto.Repo, otp_app: :megauni
end

defmodule Megauni.SQL do
  @user_err_regexp  ~r/\Auser_error: /

  def to_dollar_num_binary args do
    Enum.reduce(Enum.with_index(args), [], fn({val, i}, acc) ->
      case val do
        x when is_number(x) -> (acc ++ ["$#{i + 1}::INT"])
        x when is_binary(x) -> (acc ++ ["$#{i + 1}::VARCHAR"])
        _                   -> (acc ++ ["$#{i + 1}"])
      end
    end)
    |> Enum.join(", ")
  end

  def query sql, args do
    Ecto.Adapters.SQL.query(
     Megauni.Repos.Main, sql, args
    )
    |> ok_rows_to_list_of_maps
  end


  def max_length raw do
    case raw do
      { :error, %{postgres: %{code: :string_data_right_truncation, message: msg}} } ->
        case Regex.run( ~r/value too long for type character varying\((\d+)\)/, msg ) do
          [_match, raw_num] ->
            String.to_integer(raw_num)
          nil ->
            nil
        end
      _ ->
        nil
    end
  end # === def max_length

  def is_too_long? error_or_something_else do
    error_or_something_else |> max_length |> is_number
  end # === def is_too_long?

  defp inspect_and_raise_db_err result, err_code, msg do
    In.spect result
    raise "\n\ndatabase error: #{inspect err_code} #{msg}"
  end

  def ok_rows_to_list_of_maps raws do
    case raws do
      {:ok, %{num_rows: 0}} ->
        {:ok, []}

      # == Useful when deleting rows and "rows" are nil,
      # == while "num_rows" is a number.
      {:ok, %{num_rows: num, columns: nil, rows: nil }} ->
        {:ok,  Enum.map(1..num, &(&1 && nil))}

      {:ok, %{num_rows: _num_rows, columns: cols, rows: rows }} ->
        list_of_maps = Enum.map rows, fn(r) ->
          Enum.reduce(Enum.zip(cols, r), %{}, fn({col, raw_val}, map) ->
            val = case raw_val do
              {{_yr, _mo, _dy}, {_hr,_min,_sec,_ms}} ->
                raw_val |> Timex.Date.from |> Timex.DateFormat.format!("{ISO}")
              _   ->
                raw_val
            end
            Map.put(map, col, val)
          end)
        end

        {:ok, list_of_maps}

      _ -> raws
    end # === case raws
  end

  def to_rows! raws do
    case raws do
      {:ok, _} ->
        raws |> ok_rows_to_list_of_maps

      {:error, e} ->
        In.spect e
        raise "\n\n database error"
    end # === case raws
  end # === def rows

  def true_if_map_or_unique_violation record, type do
    cond do
      is_map(record) ->
        true
      %{"user_error"=> "#{type}: already_taken"} == record ->
        true
      true ->
        false
    end
  end

  @doc """
  This function standardizes errors. There are different
  ways to validate data on Postgresql (constraints, triggers, pgSQL funcs, etc).
  The idea is to take advantage of the "datastore" (Postgresql in this case).
    - "error" are for unforeseen errors generated by Postgresql.
    - "user_error" are foreseen that can be dealt by the user.
  """
  def one_row result, prefix \\ "unknown" do
    case result do

      {:ok, [row]} -> {:ok, row}

      {:ok, %{num_rows: 1, columns: cols, rows: [row]}} ->
        map = Enum.reduce(Enum.zip(cols, row), %{}, fn({col, val}, map) ->
          Map.put(map, col, val)
        end)
        {:ok, map}

      { :error, %{postgres: %{code: :string_data_right_truncation, message: msg}} } ->
        case Regex.run( ~r/value too long for type character varying\((\d+)\)/, msg ) do
          [_match, raw_num] ->
            max = String.to_integer(raw_num)
            {:error, {:user_error, "#{prefix}: max #{max}"}}
          nil ->
            inspect_and_raise_db_err result, :string_data_right_truncation, msg
        end

      { :error, %{postgres: %{code: :unique_violation, message: msg}} } ->
        if msg =~ ~r/violates.+"#{prefix}_unique_idx"/ do
          {:error, {:user_error,"#{prefix}: already_taken"}}
        else
          inspect_and_raise_db_err result, :unique_violation, msg
        end

      { :error, %{postgres: %{code: :raise_exception, message: msg}} } ->
        cond do
          msg =~ @user_err_regexp ->
            {:error, {:user_error, String.replace(msg, ~r/\Auser_error: /, "", global: false)}}

          true ->
            inspect_and_raise_db_err(result, :raise_exception, msg)
        end

      { :error, %{postgres: %{code: err_code, message: msg}} } ->
        inspect_and_raise_db_err(result, err_code, msg)

      {:error, e} ->
        msg            = Exception.message(e)
        err_unique_idx = ~r/violates.+"#{prefix}_unique_idx"/
        err_exception  = ~r/^ERROR \(raise_exception\): /

        cond do
          msg =~ err_unique_idx ->
            {:error, {:user_error, "#{prefix}: already_taken"}}
          msg =~ err_exception ->
            inspect_and_raise_db_err result, e, msg
        end # === cond
    end # === case
  end # === def one_row

end # === defmodule Megauni.SQL
